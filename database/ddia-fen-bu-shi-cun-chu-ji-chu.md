# DDIA-分布式存储-基础

> 设计数据密集型应用

#### 关系型数据库 vs 文档型数据库 vs 图形数据库

* 应用程序存在多对多关系，文档模型吸引力将会降低
* 对于高度相连的数据，文档模型最差，关系模型尚可，图形模型最优
* 文档数据库应用场景：数据是自我包含的，文档之间的关系较少
* 图形数据库：任意事物都可以与任何事物相关联

#### 命令式语言 & 声明式语言

命令式语言：告诉计算机以特定顺序和方式执行某些操作，达成某些结果 声明式语言：指定结果必须符合哪些条件，以及如何将数据转换（排序，组合等），而不需要说明如何去实现这一目的（这一步由查询优化器，执行器负责）

声明式语言优雅且应用广泛，如 SQL，CSS 等

#### 日志结构存储引擎 vs 面向页面存储引擎

**日志型key/value存储模型 Bitcask** 特点： 1. 写入方式为仅追加（类似日志服务），物理文件保持顺序写入，写入性能极好 2. 删除时，新增一条相同 key 的记录，并把 value 置为删除标记 3. 修改时，新增一条相同 key 的记录，把 value 设置为新值 4. 使用 hash 表索引，hash 表加载在内存中 5. 文件到大小阈值，建立新文件 6. 通过定期 merge 操作来处理旧数据，释放磁盘空间

#### 索引

大致思想和目的：存储一些额外元数据作为路标，帮助你找到想要的数据

**Hash 表索引**

缺点： 

* 散列表必须能放进内存，磁盘 hash 映射表现很差，因为需要大量的随机 I/O
* 范围查询效率较低，你必须在散列映射中单独查找每个 key

**SSTables** 

全称 Sorted String Table（排序字符串表） 

主要特点是：内容按 key 排序

* 拥有稀疏的索引表，因为 key 有序，可以通过附近的索引快速扫描查找
* 在内存中维护树形结构（红黑树 or AVL 树 or 其他方便健值查找的数据结构），写入时先写入内存表，达到阈值落磁盘
* 查找是先查内存表，再查磁盘段
* 后台定期合并和压缩段
* 通过在磁盘维护 change logs 来避免，异常崩溃导致的数据丢失

**LSM 树** 全称 Log-Structured Merge Tree（日志结构合并树） 

查阅：[https://juejin.im/post/5bbbf7615188255c59672125](https://juejin.im/post/5bbbf7615188255c59672125) 

基本思想：保存一系列在后台合并的 SSTables

* 判断 key 是否存在，可以使用 bloom filter

**B 树**

* 固定大小的块或页面，传统大小 4KB，且一次只能读取 or 写入一个页面，（磁盘也被分割在固定大小的块）
* 具有 n 个键的 B 数总是具有 O\(log n\) 的深度，分支因子为 500 的 4KB 页面的四级树可以存储 256TB 数据
* 为了处理崩溃导致的脏数据，一般会维护一个磁盘数据结构：预写式日志（追加式文件），用以崩溃恢复

